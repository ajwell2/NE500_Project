//	heat_source.h
//	Author:	A. Wells
//	Date:	2024-04-13

//	Description:
//	Models thermodynamic and heat exchange properties of an fe_heat.h decay heat source for use in thermodynamic cycle simulation.

#ifndef _HEAT_SOURCE_
#define _HEAT_SOURCE_

#include <vector>

#include "fe_heat.h"
#include "csvwrite.h"

//	--== utilities ==--

//	--== structs ==--

//	lotArray:	allows creation and modeling of a multi-lot array, with sequential assignment of newly discharged fuel elements and support
struct lotArray {
	int nLots;			//number of lots to simulate
	double dInterval;	//time between FE dispensation
	double dRate;		//rate of discharge
	double tr;			//maximum FE residence
	double to;			//operational lifespan of FE
	double qo;			//average FE power during operation
	double q_net;		//net heat generated by lot array
	vector <lot> lots;		//vector containing the lots comprising the array
	vector <double> heats;	//vector of heat contribution of the various lots

	lotArray() = default;
	lotArray(int n, double& ri, double& tri, double& toi, double& qoi) {
		nLots = n;
		dRate = ri;
		dInterval = 1 / ri;
		tr = tri;
		to = toi;
		qo = qoi;
	}

	//	arrayGen():		generates vector of lots
	void arrayGen(double& troi) {
		double tro = troi;
		double lot_rate = dRate / nLots;
		lots.clear();
		for (int i = 0; i < nLots; i++) {
			lots.push_back(lot(to, qo, tr, tro, lot_rate));
			tro += dInterval;
		};
	}

	//	arrayHeight():	returns number of elements in each column
	double arrayHeight() {
		return tr / dInterval / nLots;
	}

	//	arrayHeats():	calculates heat generation from each column
	void arrayHeats() {
		heats.clear();
		for (int j = 0; j < nLots; j++) {
			lots[j].gen_corr();
			heats.push_back(lots[j].q_net);
		};
	}

	//	netHeat():		calculates total heat generated by the array
	void netHeat() {
		q_net = 0;
		for (int i = 0; i < heats.size(); i++) {
			q_net += heats[i];
		};
	}

	//	avgflow_req_T():	calculates minimum average flow rate to achieve the desired temperature rise
	double avgflow_req_T(double& t_rise, double& Cp) {
		double m_dot_req;		
		m_dot_req = q_net / Cp / t_rise;
		return m_dot_req;
	}

	//	tRise_avg():	calculates average temperature rise in each column based on a flow rate and heat capacity
	double tRise_avg(double& m_dot, double& Cp) {
		double t_rise = 0;
		t_rise = q_net / nLots / m_dot / Cp;
		return t_rise;
	}

	//	tRise_max():	calculates maximum temperature rise in hotest column
	double tRise_max(double& m_dot, double& Cp) {
		double t_rise = 0;
		double q_max = 0;
		for (int i = 0; i < heats.size(); i++) {
			if (heats[i] > q_max) {
				q_max = heats[i];
			}
		};
		return t_rise;
	}

	//	writeHeats():	exports <heats> to csv
	void writeHeats(string& fileName) {
		int width = 1;
		write2csv(heats, fileName, width, nLots);
	}
	
};

//	--== functions ==--

//	flowReqStudy():		determines the flow requirement for an array using multiple t_rise values
vector <double> flowReqStudy(lotArray& array, vector <double>& t_rises, double &Cp) {
	vector <double> flow_reqs;
	double troi = 0;
	array.arrayGen(troi);
	array.arrayHeats();
	array.netHeat();
	for (int k = 0; k < t_rises.size(); k++) {
		std::cout << "flowReq for N = " << array.nLots << "	| T_rise = " << t_rises[k] << " C	| Cp = " << Cp << " J/kg-K" << std::endl;
		flow_reqs.push_back(array.avgflow_req_T(t_rises[k], Cp));
	};
	return flow_reqs;
}

#endif
